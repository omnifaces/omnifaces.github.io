<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Socket (OmniFaces 2.3-SNAPSHOT API)</title>
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Socket (OmniFaces 2.3-SNAPSHOT API)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Socket.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../../org/omnifaces/cdi/push/SocketChannelManager.html" title="class in org.omnifaces.cdi.push"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?org/omnifaces/cdi/push/Socket.html" target="_top">Frames</a></li>
<li><a href="Socket.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.omnifaces.cdi.push</div>
<h2 title="Class Socket" class="title">Class Socket</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li><a href="https://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/TagHandler.html?is-external=true" title="class or interface in javax.faces.view.facelets">javax.faces.view.facelets.TagHandler</a></li>
<li>
<ul class="inheritance">
<li>org.omnifaces.cdi.push.Socket</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><a href="https://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/FaceletHandler.html?is-external=true" title="class or interface in javax.faces.view.facelets">FaceletHandler</a></dd>
</dl>
<hr>
<br>
<pre>public class <span class="typeNameLabel">Socket</span>
extends <a href="https://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/TagHandler.html?is-external=true" title="class or interface in javax.faces.view.facelets">TagHandler</a></pre>
<div class="block"><p>
 The <code>&lt;o:socket&gt;</code> tag opens an one-way (server to client) web socket based push connection in client
 side which can be reached from server side via <a href="../../../../org/omnifaces/cdi/PushContext.html" title="interface in org.omnifaces.cdi"><code>PushContext</code></a> interface injected in any CDI/container managed
 artifact via <code>&#64;</code><a href="../../../../org/omnifaces/cdi/Push.html" title="annotation in org.omnifaces.cdi"><code>Push</code></a> annotation.


 <h3 id="configuration"><a href="#configuration">Configuration</a></h3>
 <p>
 First enable the web socket endpoint by below boolean context parameter in <code>web.xml</code>:
 <pre>
 &lt;context-param&gt;
     &lt;param-name&gt;org.omnifaces.ENABLE_SOCKET_ENDPOINT&lt;/param-name&gt;
     &lt;param-value&gt;true&lt;/param-value&gt;
 &lt;/context-param&gt;
 </pre>
 <p>
 It will install the <a href="../../../../org/omnifaces/cdi/push/SocketEndpoint.html" title="class in org.omnifaces.cdi.push"><code>SocketEndpoint</code></a>. Lazy initialization of the endpoint via taghandler is unfortunately not
 possible across all containers (yet).
 See also <a href="https://java.net/jira/browse/WEBSOCKET_SPEC-211">WS spec issue 211</a>.


 <h3 id="usage-client"><a href="#usage-client">Usage (client)</a></h3>
 <p>
 Declare <strong><code>&lt;o:socket&gt;</code></strong> tag in the JSF view with at least a
 <strong><code>channel</code></strong> name and an <strong><code>onmessage</code></strong> JavaScript listener
 function. The channel name may not be an EL expression and it may only contain alphanumeric characters, hyphens,
 underscores and periods.
 <p>
 Here's an example which refers an existing JavaScript listener function (do not include the parentheses!).
 <pre>
 &lt;o:socket channel="someChannel" onmessage="socketListener" /&gt;
 </pre>
 <pre>
 function socketListener(message, channel, event) {
     console.log(message);
 }
 </pre>
 <p>
 Here's an example which declares an inline JavaScript listener function.
 <pre>
 &lt;o:socket channel="someChannel" onmessage="function(message) { console.log(message); }" /&gt;
 </pre>
 <p>
 The <code>onmessage</code> JavaScript listener function will be invoked with three arguments:
 <ul>
 <li><code>message</code>: the push message as JSON object.</li>
 <li><code>channel</code>: the channel name, useful in case you intend to have a global listener, or want to manually
 control the close.</li>
 <li><code>event</code>: the raw <a href="https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent"><code>
 MessageEvent</code></a> instance, useful in case you intend to inspect it.</li>
 </ul>
 <p>
 In case your server is configured to run WS container on a different TCP port than the HTTP container, then you can
 use the <strong><code>port</code></strong> attribute to explicitly specify the port.
 <pre>
 &lt;o:socket port="8000" ... /&gt;
 </pre>
 <p>
 When successfully connected, the web socket is by default open as long as the document is open, and it will
 auto-reconnect at increasing intervals when the connection is closed/aborted as result of e.g. a network error or
 server restart. It will not auto-reconnect when the very first connection attempt already fails. The web socket will
 be implicitly closed once the document is unloaded (e.g. navigating away, close of browser window/tab, etc).


 <h3 id="usage-server"><a href="#usage-server">Usage (server)</a></h3>
 <p>
 In WAR side, you can inject <strong><a href="../../../../org/omnifaces/cdi/PushContext.html" title="interface in org.omnifaces.cdi"><code>PushContext</code></a></strong> via <strong><code>&#64;</code><a href="../../../../org/omnifaces/cdi/Push.html" title="annotation in org.omnifaces.cdi"><code>Push</code></a></strong>
 annotation on the given channel name in any CDI/container managed artifact such as <code>@Named</code>,
 <code>@WebServlet</code>, etc wherever you'd like to send a push message and then invoke
 <strong><a href="../../../../org/omnifaces/cdi/PushContext.html#send-java.lang.Object-"><code>PushContext.send(Object)</code></a></strong> with any Java object representing the push message.
 <pre>
 &#64;Inject &#64;Push
 private PushContext someChannel;

 public void sendMessage(Object message) {
     someChannel.send(message);
 }
 </pre>
 <p>
 By default the name of the channel is taken from the name of the variable into which injection takes place. The
 channel name can be optionally specified via the <code>channel</code> attribute. The example below injects the push
 context for channel name <code>foo</code> into a variable named <code>bar</code>.
 <pre>
 &#64;Inject &#64;Push(channel="foo")
 private PushContext bar;
 </pre>
 <p>
 The message object will be encoded as JSON and be delivered as <code>message</code> argument of the
 <code>onmessage</code> JavaScript listener function associated with the <code>channel</code> name. It can be a
 plain vanilla <code>String</code>, but it can also be a collection, map and even a javabean. For supported argument
 types, see also <a href="../../../../org/omnifaces/util/Json.html#encode-java.lang.Object-"><code>Json.encode(Object)</code></a>.
 <p>
 Although web sockets support two-way communication, the <code>&lt;o:socket&gt;</code> push is designed for one-way
 communication, from server to client. In case you intend to send some data from client to server, just continue
 using JSF ajax the usual way, if necessary from JavaScript on with <code>&lt;o:commandScript&gt;</code> or perhaps
 <code>&lt;p:remoteCommand&gt;</code> or similar. This has among others the advantage of maintaining the JSF view
 state, the HTTP session and, importantingly, all security constraints on business service methods. Namely, those
 security constraints are not available during an incoming web socket message per se. See also a.o.
 <a href="https://java.net/jira/browse/WEBSOCKET_SPEC-238">WS spec issue 238</a>.


 <h3 id="scopes-and-users"><a href="#scopes-and-users">Scopes and users</a></h3>
 <p>
 By default the web socket is <code>application</code> scoped, i.e. any view/session throughout the web application
 having the same web socket channel open will receive the same push message. The push message can be sent by all users
 and the application itself. This is useful for application-wide feedback triggered by site itself such as real time
 updates of a certain page (e.g. site-wide statistics, top100 lists, stock updates, etc).
 <p>
 The optional <strong><code>scope</code></strong> attribute can be set to <code>session</code> to restrict the push
 messages to all views in the current user session only. The push message can only be sent by the user itself and not
 by the application. This is useful for session-wide feedback triggered by user itself (e.g. as result of asynchronous
 tasks triggered by user specific action).
 <pre>
 &lt;o:socket channel="someChannel" scope="session" ... /&gt;
 </pre>
 <p>
 The <code>scope</code> attribute can also be set to <code>view</code> to restrict the push messages to the current
 view only. The push message will not show up in other views in the same session even if it's the same URL. The push
 message can only be sent by the user itself and not by the application. This is useful for view-wide feedback
 triggered by user itself (e.g. progress bar tied to a user specific action on current view).
 <pre>
 &lt;o:socket channel="someChannel" scope="view" ... /&gt;
 </pre>
 <p>
 The <code>scope</code> attribute may not be an EL expression and allowed values are <code>application</code>,
 <code>session</code> and <code>view</code>, case insensitive.
 <p>
 Additionally, the optional <strong><code>user</code></strong> attribute can be set to the unique identifier of the
 logged-in user, usually the login name or the user ID. This way the push message can be targeted to a specific user
 and can also be sent by other users and the application itself. The value of the <code>user</code> attribute must at
 least implement <a href="http://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html?is-external=true" title="class or interface in java.io"><code>Serializable</code></a> and have a low memory footprint, so putting entire user entity is not
 recommended.
 <p>
 E.g. when you're using container managed authentication or a related framework/library:
 <pre>
 &lt;o:socket channel="someChannel" user="#{request.remoteUser}" ... /&gt;
 </pre>
 <p>
 Or when you have a custom user entity around in EL as <code>#{someLoggedInUser}</code> which has an <code>id</code>
 property representing its identifier:
 <pre>
 &lt;o:socket channel="someChannel" user="#{someLoggedInUser.id}" ... /&gt;
 </pre>
 <p>
 When the <code>user</code> attribute is specified, then the <code>scope</code> defaults to <code>session</code> and
 cannot be set to <code>application</code>. It can be set to <code>view</code>, but this is kind of unusual and should
 only be used if the logged-in user represented by <code>user</code> has a shorter lifetime than the HTTP session
 (e.g. when your application allows changing a logged-in user during same HTTP session without invaliding it &mdash;
 which is in turn poor security practice). If in such case a session scoped socket is reused, undefined behavior may
 occur when user-targeted push message is sent. It may target previously logged-in user only. This can be solved by
 setting the scope to <code>view</code>, but better is to fix the logout to invalidate the HTTP session altogether.
 <p>
 In the server side, the push message can be targeted to the user specified in the <code>user</code> attribute via
 <strong><a href="../../../../org/omnifaces/cdi/PushContext.html#send-java.lang.Object-S-"><code>PushContext.send(Object, Serializable)</code></a></strong>. The push message can be sent by all users and the
 application itself. This is useful for user-specific feedback triggered by other users (e.g. chat, admin messages,
 etc) or by application's background tasks (e.g. notifications, event listeners, etc).
 <pre>
 &#64;Inject &#64;Push
 private PushContext someChannel;

 public void sendMessage(Object message, User recipientUser) {
     Long recipientUserId = recipientUser.getId();
     someChannel.send(message, recipientUserId);
 }
 </pre>
 <p>
 Multiple users can be targeted by passing a <a href="http://docs.oracle.com/javase/7/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util"><code>Collection</code></a> holding user identifiers to
 <strong><a href="../../../../org/omnifaces/cdi/PushContext.html#send-java.lang.Object-java.util.Collection-"><code>PushContext.send(Object, Collection)</code></a></strong>.
 <pre>
 public void sendMessage(Object message, Group recipientGroup) {
     Collection&lt;Long&gt; recipientUserIds = recipientGroup.getUserIds();
     someChannel.send(message, recipientUserIds);
 }
 </pre>


 <h3 id="channels"><a href="#channels">Channel design hints</a></h3>
 <p>
 You can declare multiple push channels on different scopes with or without user target throughout the application.
 Be however aware that the same channel name can easily be reused across multiple views, even if it's view scoped.
 It's more efficient if you use as few different channel names as possible and tie the channel name to a specific
 push socket scope/user combination, not to a specific JSF view. In case you intend to have multiple view scoped
 channels for different purposes, best is to use only one view scoped channel and have a global JavaScript listener
 which can distinguish its task based on the delivered message. E.g. by sending the message in server as below:
 <pre>
 Map&lt;String, Object&gt; message = new HashMap&lt;&gt;();
 message.put("functionName", "someFunction");
 message.put("functionData", functionData); // Can be Map or Bean.
 someChannel.send(message);
 </pre>
 <p>
 Which is processed in the <code>onmessage</code> JavaScript listener function as below:
 <pre>
 function someSocketListener(message) {
     window[message.functionName](message.functionData);
 }

 function someFunction(data) {
     // ...
 }

 function otherFunction(data) {
     // ...
 }

 // ...
 </pre>


 <h3 id="connecting"><a href="#connecting">Conditionally connecting</a></h3>
 <p>
 You can use the optional <strong><code>connected</code></strong> attribute to control whether to auto-connect the web
 socket or not.
 <pre>
 &lt;o:socket ... connected="#{bean.pushable}" /&gt;
 </pre>
 <p>
 It defaults to <code>true</code> and it's under the covers interpreted as a JavaScript instruction whether to open or
 close the web socket push connection. If the value is an EL expression and it becomes <code>false</code> during an
 ajax request, then the push connection will explicitly be closed during oncomplete of that ajax request, even though
 you did not cover the <code>&lt;o:socket&gt;</code> tag in ajax render/update. So make sure it's tied to at least a
 view scoped property in case you intend to control it during the view scope.
 <p>
 You can also explicitly set it to <code>false</code> and manually open the push connection in client side by
 invoking <strong><code>OmniFaces.Push.open(channel)</code></strong>, passing the channel name, for example in an
 onclick listener function of a command button which initiates a long running asynchronous task in server side. This
 is particularly useful on view scoped sockets which doesn't necessarily need to immediately open on page load.
 <pre>
 &lt;h:commandButton ... onclick="OmniFaces.Push.open('foo')"&gt;
     &lt;f:ajax ... /&gt;
 &lt;/h:commandButton&gt;
 &lt;o:socket channel="foo" scope="view" ... connected="false" /&gt;
 </pre>
 <p>
 In case you intend to have an one-time push and don't expect more messages, usually because you only wanted to
 present the result of an one-time asynchronous action in a manually opened view scoped push socket as in above
 example, you can optionally explicitly close the push connection from client side by invoking
 <strong><code>OmniFaces.Push.close(channel)</code></strong>, passing the channel name. For example, in the
 <code>onmessage</code> JavaScript listener function as below:
 <pre>
 function someSocketListener(message, channel) {
     // ...
     OmniFaces.Push.close(channel);
 }
 </pre>
 <p>
 Noted should be that both ways should not be mixed. Choose either the server side way of an EL expression in
 <code>connected</code> attribute, or the client side way of explicitly setting <code>connected="false"</code> and
 manually invoking <code>OmniFaces.Push</code> functions. Mixing them ends up in undefined behavior because the
 associated JSF view state in the server side can't be notified if a socket is manually opened in client side.


 <h3 id="events-client"><a href="#events-client">Events (client)</a></h3>
 <p>
 The optional <strong><code>onopen</code></strong> JavaScript listener function can be used to listen on open of a web
 socket in client side. This will be invoked on the very first connection attempt, regardless of whether it will be
 successful or not. This will not be invoked when the web socket auto-reconnects a broken connection after the first
 successful connection.
 <pre>
 &lt;o:socket ... onopen="socketOpenListener" /&gt;
 </pre>
 <pre>
 function socketOpenListener(channel) {
     // ...
 }
 </pre>
 <p>
 The <code>onopen</code> JavaScript listener function will be invoked with one argument:
 <ul>
 <li><code>channel</code>: the channel name, useful in case you intend to have a global listener.</li>
 </ul>
 <p>
 The optional <strong><code>onclose</code></strong> JavaScript listener function can be used to listen on (ab)normal
 close of a web socket. This will be invoked when the very first connection attempt fails, or the maximum reconnect
 attempts has exceeded, or the server has returned close reason code <code>1000</code> or <code>1008</code> (policy
 violated, which usually only happens when the channel name is unknown, or the session has expired). This will not be
 invoked when the web socket can make an auto-reconnect attempt on a broken connection after the first successful
 connection.
 <pre>
 &lt;o:socket ... onclose="socketCloseListener" /&gt;
 </pre>
 <pre>
 function socketCloseListener(code, channel, event) {
     if (code == -1) {
         // Web sockets not supported by client.
     } else if (code != 1000) {
         // Abnormal close reason.
     }
 }
 </pre>
 <p>
 The <code>onclose</code> JavaScript listener function will be invoked with three arguments:
 <ul>
 <li><code>code</code>: the close reason code as integer. If this is <code>-1</code>, then the web socket
 is simply not <a href="http://caniuse.com/websockets">supported</a> by the client. If this is <code>1000</code>,
 then it was normally closed. Else if this is not <code>1000</code>, then there may be an error. See also
 <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1">RFC 6455 section 7.4.1</a> and <a href="https://docs.oracle.com/javaee/7/api/javax/websocket/CloseReason.CloseCodes.html?is-external=true" title="class or interface in javax.websocket"><code>CloseReason.CloseCodes</code></a> API for
 an elaborate list of all close codes.</li>
 <li><code>channel</code>: the channel name, useful in case you intend to have a global listener.</li>
 <li><code>event</code>: the raw <a href="https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent"><code>
 CloseEvent</code></a> instance, useful in case you intend to inspect it.</li>
 </ul>
 <p>
 When a session or view scoped socket is automatically closed with close reason code <code>1000</code> by the server
 (and thus not manually by the client via <code>OmniFaces.Push.close(channel)</code>), then it means that the session
 or view has expired. In case of a session scoped socket you could take the opportunity to let JavaScript show a
 "Session expired" message and/or immediately redirect to the login page via <code>window.location</code>. In case of
 a view scoped socket the handling depends on the reason of the view expiration. A view can be expired when the
 associated session has expired, but it can also be expired as result of (accidental) navigation or rebuild, or when
 the JSF "views per session" configuration setting is set relatively low and the client has many views (windows/tabs)
 open in the same session. You might take the opportunity to let JavaScript reload the page.


 <h3 id="events-server"><a href="#events-server">Events (server)</a></h3>
 <p>
 When a web socket has been opened, a new CDI <strong><a href="../../../../org/omnifaces/cdi/push/SocketEvent.html" title="class in org.omnifaces.cdi.push"><code>SocketEvent</code></a></strong> will be fired with
 <strong><code>&#64;</code><a href="../../../../org/omnifaces/cdi/push/event/Opened.html" title="annotation in org.omnifaces.cdi.push.event"><code>Opened</code></a></strong> qualifier. When a web socket has been closed, a new CDI
 <a href="../../../../org/omnifaces/cdi/push/SocketEvent.html" title="class in org.omnifaces.cdi.push"><code>SocketEvent</code></a> will be fired with <strong><code>&#64;</code><a href="../../../../org/omnifaces/cdi/push/event/Closed.html" title="annotation in org.omnifaces.cdi.push.event"><code>Closed</code></a></strong> qualifier. They can only be
 observed and collected in an application scoped CDI bean as below. A request/view/session scoped one wouldn't work as
 there's no means of a HTTP request anywhere at that moment.
 <pre>
 &#64;ApplicationScoped
 public class SocketObserver {

     public void onOpen(&#64;Observes &#64;Opened SocketEvent event) {
         String channel = event.getChannel(); // Returns &lt;o:socket channel&gt;.
         Long userId = event.getUser(); // Returns &lt;o:socket user&gt;, if any.
         // Do your thing with it. E.g. collecting them in a concurrent/synchronized collection.
         // Do note that a single person can open multiple sockets on same channel/user.
     }

     public void onClose(&#64;Observes &#64;Closed SocketEvent event) {
         String channel = event.getChannel(); // Returns &lt;o:socket channel&gt;.
         Long userId = event.getUser(); // Returns &lt;o:socket user&gt;, if any.
         CloseCode code = event.getCloseCode(); // Returns close reason code.
         // Do your thing with it. E.g. removing them from collection.
     }

 }
 </pre>
 <p>
 You could take the opportunity to send another push message to an application scoped socket, e.g. "User X has been
 logged in" (or out) when a session scoped socket is opened (or closed).


 <h3 id="security"><a href="#security">Security considerations</a></h3>
 <p>
 If the socket is declared in a page which is only restricted to logged-in users with a specific role, then you may
 want to add the URL of the push handshake request URL to the set of restricted URLs.
 <p>
 The push handshake request URL is composed of the URI prefix <strong><code>/omnifaces.push/</code></strong>, followed
 by channel name. So, in case of for example container managed security which has already restricted an example page
 <code>/user/foo.xhtml</code> to logged-in users with the example role <code>USER</code> on the example URL pattern
 <code>/user/*</code> in <code>web.xml</code> like below,
 <pre>
 &lt;security-constraint&gt;
     &lt;web-resource-collection&gt;
         &lt;web-resource-name&gt;Restrict access to role USER.&lt;/web-resource-name&gt;
         &lt;url-pattern&gt;/user/*&lt;/url-pattern&gt;
     &lt;/web-resource-collection&gt;
     &lt;auth-constraint&gt;
         &lt;role-name&gt;USER&lt;/role-name&gt;
     &lt;/auth-constraint&gt;
 &lt;/security-constraint&gt;
 </pre>
 <p>
 .. and the page <code>/user/foo.xhtml</code> in turn contains a <code>&lt;o:socket channel="foo"&gt;</code>, then you
 need to add a restriction on push handshake request URL pattern of <code>/omnifaces.push/foo</code> like below.
 <pre>
 &lt;security-constraint&gt;
     &lt;web-resource-collection&gt;
         &lt;web-resource-name&gt;Restrict access to role USER.&lt;/web-resource-name&gt;
         &lt;url-pattern&gt;/user/*&lt;/url-pattern&gt;
         &lt;url-pattern&gt;/omnifaces.push/foo&lt;/url-pattern&gt;
     &lt;/web-resource-collection&gt;
     &lt;auth-constraint&gt;
         &lt;role-name&gt;USER&lt;/role-name&gt;
     &lt;/auth-constraint&gt;
 &lt;/security-constraint&gt;
 </pre>
 <p>
 As extra security, particularly for those public channels which can't be restricted by security constraints, the
 <code>&lt;o:socket&gt;</code> will register all so far declared channels in the current HTTP session, and any
 incoming web socket open request will be checked whether they match the so far registered channels in the current
 HTTP session. In case the channel is unknown (e.g. randomly guessed or spoofed by endusers), then the web socket will
 immediately be closed with close reason code <a href="https://docs.oracle.com/javaee/7/api/javax/websocket/CloseReason.CloseCodes.html?is-external=true#VIOLATED_POLICY" title="class or interface in javax.websocket"><code>CloseReason.CloseCodes.VIOLATED_POLICY</code></a> (<code>1008</code>). Also, when the
 HTTP session gets destroyed, all session and view scoped channels which are still open will explicitly be closed
 from server side with close reason code <a href="https://docs.oracle.com/javaee/7/api/javax/websocket/CloseReason.CloseCodes.html?is-external=true#NORMAL_CLOSURE" title="class or interface in javax.websocket"><code>CloseReason.CloseCodes.NORMAL_CLOSURE</code></a> (<code>1000</code>). Only application
 scoped sockets remain open and are still reachable from server end even when the session or view is expired on client
 side.


 <h3 id="ejb"><a href="#ejb">EJB design hints</a></h3>
 <p>
 In case you'd like to trigger a push from EAR/EJB side to an application scoped push socket, then you could make use
 of CDI events. First create a custom bean class representing the push event something like <code>PushEvent</code>
 below taking whatever you'd like to pass as push message.
 <pre>
 public class PushEvent {

     private final String message;

     public PushEvent(String message) {
         this.message = message;
     }

     public String getMessage() {
         return message;
     }
 }
 </pre>
 <p>
 Then use <a href="https://docs.oracle.com/javaee/7/api/javax/enterprise/inject/spi/BeanManager.html?is-external=true#fireEvent-java.lang.Object-java.lang.annotation.Annotation...-" title="class or interface in javax.enterprise.inject.spi"><code>BeanManager.fireEvent(Object, java.lang.annotation.Annotation...)</code></a> to
 fire the CDI event.
 <pre>
 &#64;Inject
 private BeanManager beanManager;

 public void onSomeEntityChange(Entity entity) {
     beanManager.fireEvent(new PushEvent(entity.getSomeProperty()));
 }
 </pre>
 <p>
 Note that OmniFaces own <a href="../../../../org/omnifaces/util/Beans.html#fireEvent-java.lang.Object-java.lang.annotation.Annotation...-"><code>Beans.fireEvent(Object, java.lang.annotation.Annotation...)</code></a> utility method is
 insuitable as it is not allowed to use WAR (front end) frameworks and libraries like JSF and OmniFaces in EAR/EJB
 (back end) side.
 <p>
 Finally just <code>&#64;</code><a href="https://docs.oracle.com/javaee/7/api/javax/enterprise/event/Observes.html?is-external=true" title="class or interface in javax.enterprise.event"><code>Observes</code></a> it in some request or application scoped CDI managed bean in WAR and
 delegate to <a href="../../../../org/omnifaces/cdi/PushContext.html" title="interface in org.omnifaces.cdi"><code>PushContext</code></a> as below.
 <pre>
 &#64;Inject &#64;Push
 private PushContext someChannel;

 public void onPushEvent(@Observes PushEvent event) {
     someChannel.send(event.getMessage());
 }
 </pre>
 <p>
 Note that a request scoped bean wouldn't be the same one as from the originating page for the simple reason that
 there's no means of a HTTP request anywhere at that moment. For exactly this reason a view and session scoped bean
 would not work (as they require respectively the JSF view state and HTTP session which can only be identified by a
 HTTP request). A view and session scoped push socket would also not work, so the push socket really needs to be
 application scoped. The <a href="https://docs.oracle.com/javaee/7/api/javax/faces/context/FacesContext.html?is-external=true" title="class or interface in javax.faces.context"><code>FacesContext</code></a> will also be unavailable in the above event listener method.
 <p>
 In case the trigger in EAR/EJB side is an asynchronous service method which is in turn initiated in WAR side, then
 you could make use of callbacks from WAR side. Let the business service method take a callback instance as argument,
 e.g. the <code>java.util.function.Consumer</code> functional interface.
 <pre>
 &#64;Asynchronous
 public void someAsyncServiceMethod(Entity entity, Consumer&lt;Object&gt; callback) {
     // ... (some long process)
     callback.accept(entity.getSomeProperty());
 }
 </pre>
 <p>
 And invoke the asynchronous service method in WAR as below.
 <pre>
 &#64;Inject
 private SomeService someService;

 &#64;Inject &#64;Push
 private PushContext someChannel;

 public void submit() {
     someService.someAsyncServiceMethod(entity, message -&gt; someChannel.send(message));
 }
 </pre>
 <p>
 This would be the only way in case you intend to asynchronously send a message to a view or session scoped push
 socket, and/or want to pass something from <a href="https://docs.oracle.com/javaee/7/api/javax/faces/context/FacesContext.html?is-external=true" title="class or interface in javax.faces.context"><code>FacesContext</code></a> or the initial request/view/session scope along as
 (<code>final</code>) argument.
 <p>
 In case you're not on Java 8 yet, then you can make use of <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Runnable.html?is-external=true" title="class or interface in java.lang"><code>Runnable</code></a> as callback instance instead of the
 above <code>Consumer</code> functional interface example.
 <pre>
 &#64;Asynchronous
 public void someAsyncServiceMethod(Entity entity, Runnable callback) {
     // ... (some long process)
     entity.setSomeProperty(someProperty);
     callback.run();
 }
 </pre>
 <p>
 Which is invoked in WAR as below.
 <pre>
 public void submit() {
     someService.someAsyncServiceMethod(entity, new Runnable() {
         public void run() {
             someChannel.send(entity.getSomeProperty());
         }
     });
 }
 </pre>
 <p>
 Note that OmniFaces own <a href="../../../../org/omnifaces/util/Callback.html" title="class in org.omnifaces.util"><code>Callback</code></a> interfaces are insuitable as it is not allowed to use WAR (front end)
 frameworks and libraries like JSF and OmniFaces in EAR/EJB (back end) side.


 <h3 id="ui"><a href="#ui">UI update design hints</a></h3>
 <p>
 In case you'd like to perform complex UI updates, which would be a piece of cake with JSF ajax, then easiest would
 be to combine <code>&lt;o:socket&gt;</code> with <code>&lt;o:commandScript&gt;</code> which simply invokes a bean
 action and ajax-updates the UI once a push message arrives. The combination can look like below:
 <pre>
 &lt;h:panelGroup id="foo"&gt;
     ... (some complex UI here) ...
 &lt;/h:panelGroup&gt;

 &lt;o:socket channel="someChannel" scope="view" onmessage="someCommandScript" /&gt;
 &lt;o:commandScript name="someCommandScript" action="#{bean.pushed}" render="foo" /&gt;
 </pre>
 <p>
 If you pass a <code>Map&lt;String,V&gt;</code> or a JavaBean as push message object, then all entries/properties will
 transparently be available as request parameters in the command script method <code>#{bean.pushed}</code>.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.3</dd>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>Bauke Scholtz</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../org/omnifaces/cdi/push/SocketEndpoint.html" title="class in org.omnifaces.cdi.push"><code>SocketEndpoint</code></a>, 
<a href="../../../../org/omnifaces/cdi/push/SocketFacesListener.html" title="class in org.omnifaces.cdi.push"><code>SocketFacesListener</code></a>, 
<a href="../../../../org/omnifaces/cdi/push/SocketChannelManager.html" title="class in org.omnifaces.cdi.push"><code>SocketChannelManager</code></a>, 
<a href="../../../../org/omnifaces/cdi/push/SocketUserManager.html" title="class in org.omnifaces.cdi.push"><code>SocketUserManager</code></a>, 
<a href="../../../../org/omnifaces/cdi/push/SocketSessionManager.html" title="class in org.omnifaces.cdi.push"><code>SocketSessionManager</code></a>, 
<a href="../../../../org/omnifaces/cdi/push/SocketEvent.html" title="class in org.omnifaces.cdi.push"><code>SocketEvent</code></a>, 
<a href="../../../../org/omnifaces/cdi/push/event/Opened.html" title="annotation in org.omnifaces.cdi.push.event"><code>Opened</code></a>, 
<a href="../../../../org/omnifaces/cdi/push/event/Closed.html" title="annotation in org.omnifaces.cdi.push.event"><code>Closed</code></a>, 
<a href="../../../../org/omnifaces/cdi/Push.html" title="annotation in org.omnifaces.cdi"><code>Push</code></a>, 
<a href="../../../../org/omnifaces/cdi/PushContext.html" title="interface in org.omnifaces.cdi"><code>PushContext</code></a>, 
<a href="../../../../org/omnifaces/cdi/push/SocketPushContext.html" title="class in org.omnifaces.cdi.push"><code>SocketPushContext</code></a>, 
<a href="../../../../org/omnifaces/cdi/push/SocketPushContextProducer.html" title="class in org.omnifaces.cdi.push"><code>SocketPushContextProducer</code></a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/omnifaces/cdi/push/Socket.html#PARAM_ENABLE_SOCKET_ENDPOINT">PARAM_ENABLE_SOCKET_ENDPOINT</a></span></code>
<div class="block">The boolean context parameter name to register web socket endpoint during startup.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="fields.inherited.from.class.javax.faces.view.facelets.TagHandler">
<!--   -->
</a>
<h3>Fields inherited from class&nbsp;javax.faces.view.facelets.<a href="https://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/TagHandler.html?is-external=true" title="class or interface in javax.faces.view.facelets">TagHandler</a></h3>
<code><a href="https://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/TagHandler.html?is-external=true#nextHandler" title="class or interface in javax.faces.view.facelets">nextHandler</a>, <a href="https://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/TagHandler.html?is-external=true#tag" title="class or interface in javax.faces.view.facelets">tag</a>, <a href="https://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/TagHandler.html?is-external=true#tagId" title="class or interface in javax.faces.view.facelets">tagId</a></code></li>
</ul>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../../org/omnifaces/cdi/push/Socket.html#Socket-javax.faces.view.facelets.TagConfig-">Socket</a></span>(<a href="https://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/TagConfig.html?is-external=true" title="class or interface in javax.faces.view.facelets">TagConfig</a>&nbsp;config)</code>
<div class="block">The tag constructor.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/omnifaces/cdi/push/Socket.html#apply-javax.faces.view.facelets.FaceletContext-javax.faces.component.UIComponent-">apply</a></span>(<a href="https://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/FaceletContext.html?is-external=true" title="class or interface in javax.faces.view.facelets">FaceletContext</a>&nbsp;context,
     <a href="https://docs.oracle.com/javaee/7/api/javax/faces/component/UIComponent.html?is-external=true" title="class or interface in javax.faces.component">UIComponent</a>&nbsp;parent)</code>
<div class="block">First check if the web socket endpoint is enabled in <code>web.xml</code> and the channel name and scope is
 valid, then register it in <a href="../../../../org/omnifaces/cdi/push/SocketChannelManager.html" title="class in org.omnifaces.cdi.push"><code>SocketChannelManager</code></a> and get the channel ID, then subcribe the
 <a href="../../../../org/omnifaces/cdi/push/SocketFacesListener.html" title="class in org.omnifaces.cdi.push"><code>SocketFacesListener</code></a>.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/omnifaces/cdi/push/Socket.html#registerEndpointIfNecessary-javax.servlet.ServletContext-">registerEndpointIfNecessary</a></span>(<a href="https://docs.oracle.com/javaee/7/api/javax/servlet/ServletContext.html?is-external=true" title="class or interface in javax.servlet">ServletContext</a>&nbsp;context)</code>
<div class="block">Register web socket endpoint if necessary, i.e.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.javax.faces.view.facelets.TagHandler">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;javax.faces.view.facelets.<a href="https://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/TagHandler.html?is-external=true" title="class or interface in javax.faces.view.facelets">TagHandler</a></h3>
<code><a href="https://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/TagHandler.html?is-external=true#getAttribute-java.lang.String-" title="class or interface in javax.faces.view.facelets">getAttribute</a>, <a href="https://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/TagHandler.html?is-external=true#getRequiredAttribute-java.lang.String-" title="class or interface in javax.faces.view.facelets">getRequiredAttribute</a>, <a href="https://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/TagHandler.html?is-external=true#toString--" title="class or interface in javax.faces.view.facelets">toString</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a></h3>
<code><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#clone--" title="class or interface in java.lang">clone</a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#equals-java.lang.Object-" title="class or interface in java.lang">equals</a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#finalize--" title="class or interface in java.lang">finalize</a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#getClass--" title="class or interface in java.lang">getClass</a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#hashCode--" title="class or interface in java.lang">hashCode</a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#notify--" title="class or interface in java.lang">notify</a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#notifyAll--" title="class or interface in java.lang">notifyAll</a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#wait--" title="class or interface in java.lang">wait</a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#wait-long-" title="class or interface in java.lang">wait</a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html?is-external=true#wait-long-int-" title="class or interface in java.lang">wait</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="PARAM_ENABLE_SOCKET_ENDPOINT">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>PARAM_ENABLE_SOCKET_ENDPOINT</h4>
<pre>public static final&nbsp;<a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a> PARAM_ENABLE_SOCKET_ENDPOINT</pre>
<div class="block">The boolean context parameter name to register web socket endpoint during startup.</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../../constant-values.html#org.omnifaces.cdi.push.Socket.PARAM_ENABLE_SOCKET_ENDPOINT">Constant Field Values</a></dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Socket-javax.faces.view.facelets.TagConfig-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Socket</h4>
<pre>public&nbsp;Socket(<a href="https://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/TagConfig.html?is-external=true" title="class or interface in javax.faces.view.facelets">TagConfig</a>&nbsp;config)</pre>
<div class="block">The tag constructor. It will extract and validate the attributes.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>config</code> - The tag config.</dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="apply-javax.faces.view.facelets.FaceletContext-javax.faces.component.UIComponent-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>apply</h4>
<pre>public&nbsp;void&nbsp;apply(<a href="https://docs.oracle.com/javaee/7/api/javax/faces/view/facelets/FaceletContext.html?is-external=true" title="class or interface in javax.faces.view.facelets">FaceletContext</a>&nbsp;context,
                  <a href="https://docs.oracle.com/javaee/7/api/javax/faces/component/UIComponent.html?is-external=true" title="class or interface in javax.faces.component">UIComponent</a>&nbsp;parent)
           throws <a href="http://docs.oracle.com/javase/7/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</a></pre>
<div class="block">First check if the web socket endpoint is enabled in <code>web.xml</code> and the channel name and scope is
 valid, then register it in <a href="../../../../org/omnifaces/cdi/push/SocketChannelManager.html" title="class in org.omnifaces.cdi.push"><code>SocketChannelManager</code></a> and get the channel ID, then subcribe the
 <a href="../../../../org/omnifaces/cdi/push/SocketFacesListener.html" title="class in org.omnifaces.cdi.push"><code>SocketFacesListener</code></a>.</div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html?is-external=true" title="class or interface in java.lang">IllegalStateException</a></code> - When the web socket endpoint is not enabled in <code>web.xml</code>.</dd>
<dd><code><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang">IllegalArgumentException</a></code> - When the channel name, scope or user is invalid.
 The channel name may only contain alphanumeric characters, hyphens, underscores and periods.
 The allowed channel scope values are "application", "session" and "view", case insensitive.
 The channel name must be uniquely tied to the channel scope.
 The user, if any, must implement <code>Serializable</code>.</dd>
<dd><code><a href="http://docs.oracle.com/javase/7/docs/api/java/io/IOException.html?is-external=true" title="class or interface in java.io">IOException</a></code></dd>
</dl>
</li>
</ul>
<a name="registerEndpointIfNecessary-javax.servlet.ServletContext-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>registerEndpointIfNecessary</h4>
<pre>public static&nbsp;void&nbsp;registerEndpointIfNecessary(<a href="https://docs.oracle.com/javaee/7/api/javax/servlet/ServletContext.html?is-external=true" title="class or interface in javax.servlet">ServletContext</a>&nbsp;context)</pre>
<div class="block">Register web socket endpoint if necessary, i.e. when it's enabled via context param and not already installed.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>context</code> - The involved servlet context.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Socket.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../../org/omnifaces/cdi/push/SocketChannelManager.html" title="class in org.omnifaces.cdi.push"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?org/omnifaces/cdi/push/Socket.html" target="_top">Frames</a></li>
<li><a href="Socket.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 2012&#x2013;2016 <a href="http://omnifaces.org">OmniFaces</a>. All rights reserved.</small></p>
</body>
</html>
