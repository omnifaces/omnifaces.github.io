<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en" xmlns:javaee="http://xmlns.jcp.org/xml/ns/javaee" xmlns:vdldoc="http://vdldoc.omnifaces.org" xmlns:fo="http://www.w3.org/1999/XSL/Format">
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>o (OmniFaces VDL Documentation - Generated Documentation)
			</title>
<link rel="stylesheet" type="text/css" title="Style" href="../stylesheet.css">
</head>
<body>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="topNav">
<a name="navbar_top"></a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow"></a>
<ul class="navList" title="Navigation">
<li>
<a href="../overview-summary.html">Overview</a>
</li>
<li class="navBarCell1Rev">Library</li>
<li>Tag</li>
<li>
<a href="../help-doc.html">Help</a>
</li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>
<a target="_top" href="../index.html?o/tld-summary.html">
									Frames
								</a>
</li>
<li>
<a href="tld-summary.html" target="_top">No Frames</a>
</li>
</ul>
<ul class="navList" id="alltags_navbar_top">
<li>
<a href="../alltags-noframe.html">All Tags</a>
</li>
</ul>
<div>
<script type="text/javascript">
								document.getElementById("alltags_navbar_top").style.display = (window == top) ? "block" : "none";
							</script>
</div>
<a name="skip-navbar_top"></a>
</div>
<div class="header">
<h1 title="Library" class="title">o</h1>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>XML Declaration Syntax:</dt>
<dd>
<code>
													&lt;anyxmlelement xmlns:o="http://omnifaces.org/ui"/&gt;
												</code>
</dd>
</dl>
<dl>
<dt>Description:</dt>
<dd>
<div class="block">OmniFaces UI components.</div>
</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Library Summary table, listing library information">
<caption>
<span>Tag Library Information</span><span class="tabEnd">&nbsp;</span>
</caption>
<thead>
<tr>
<th class="colFirst" scope="col">Info</th><th class="colLast" scope="col">Value</th>
</tr>
</thead>
<tbody>
<tr class="rowColor">
<td class="colFirst">ID (tag prefix)</td><td class="colLast"><code>o</code></td>
</tr>
<tr class="altColor">
<td class="colFirst">URI</td><td class="colLast"><code>http://omnifaces.org/ui</code></td>
</tr>
</tbody>
</table>
</div>
<div class="summary">
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Tag Summary table, listing tag information">
<caption>
<span>Tag Summary</span><span class="tabEnd">&nbsp;</span>
</caption>
<thead>
<tr>
<th class="colOne" scope="col">Tag</th><th class="colLast" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="rowColor">
<td class="colOne"><b><a href="tree.html">tree</a></b></td><td class="colLast">
			
				The <code>&lt;o:tree&gt;</code> allows the developers to have full control over the markup of a tree
				hierarchy by declaring the appropriate JSF components or HTML elements in the markup. The <code>&lt;o:tree&gt;</code>
				does namely not render any HTML markup by itself.
				<p>
				The component value must point to a tree of data objects represented by a <code>TreeModel</code> instance, typically
				established via a <code>ValueExpression</code>. During iterative processing over the nodes of tree in the tree model,
				the object for the current node is exposed as a request attribute under the key specified by the <code>var</code>
				attribute. The node itself is exposed as a request attribute under the key specified by the <code>varNode</code>
				attribute.
				<p>
				The <code>&lt;o:tree&gt;</code> tag supports only child tags of type <code>&lt;o:treeNode&gt;</code>, representing
				parent tree nodes. There can be multiple <code>&lt;o:treeNode&gt;</code> tags, each representing a separate parent
				tree node level, so that different markup could be declared for each tree node level, if necessary. The
				<code>&lt;o:treeNode&gt;</code> tag in turn supports child tag <code>&lt;o:treeNodeItem&gt;</code> which represents
				each child of the current parent tree node. The <code>&lt;o:treeNodeItem&gt;</code> in turn supports child tag
				<code>&lt;o:treeInsertChildren&gt;</code> which represents the insertion point of the grand children.
				<p>
				Here is a basic usage example where each parent tree node level is treated the same way via a single
				<code>&lt;o:treeNode&gt;</code>:
				<pre>
&lt;o:tree value="#{bean.treeModel}" var="item" varNode="node"&gt;
  &lt;o:treeNode&gt;
    &lt;ul&gt;
      &lt;o:treeNodeItem&gt;
        &lt;li&gt;
          #{node.index} #{item.someProperty}
          &lt;o:treeInsertChildren /&gt;
        &lt;/li&gt;
      &lt;/o:treeNodeItem&gt;
    &lt;/ul&gt;
  &lt;/o:treeNode&gt;
&lt;/o:tree&gt;
				</pre>
			
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="treeNode.html">treeNode</a></b></td><td class="colLast">
			
				The <code>&lt;o:treeNode&gt;</code> represents the parent tree node. Within this component, the <code>var</code>
				attribute of the <code>&lt;o:tree&gt;</code> will expose the parent tree node. Each of its children is processed by
				<code>&lt;o:treeNodeItem&gt;</code> on which the <code>var</code> attribute of the <code>&lt;o:tree&gt;</code> in
				turn exposes each child of the parent tree node.
				<p>
				The optional <code>level</code> attribute can be used to specify for which tree node level as obtained by
				<code>TreeModel#getLevel()</code> the <code>&lt;o:treeNode&gt;</code> should be rendered. The root tree node has level 0.
				If the <code>level</code> attribute is unspecified, then the <code>&lt;o:treeNode&gt;</code> will be rendered for any
				tree node level which hasn't already a <code>&lt;o:treeNode level="x"&gt;</code> specified.
			
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="treeNodeItem.html">treeNodeItem</a></b></td><td class="colLast">
			
				The <code>&lt;o:treeNodeItem&gt;</code> represents the child item of the parent tree note as represented by
				<code>&lt;o:treeNode&gt;</code>. Within this component, the <code>var</code> attribute of the parent
				<code>&lt;o:tree&gt;</code> component will expose the child tree node.
				<p>
				Within <code>&lt;o:treeNodeItem&gt;</code> you can use <code>&lt;o:treeInsertChildren&gt;</code> to declare the
				place where to recursively render the <code>&lt;o:treeNode&gt;</code> whereby the current child item is in turn
				interpreted as a parent tree node (i.e. where you'd like to insert the grand-children).
			
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="treeInsertChildren.html">treeInsertChildren</a></b></td><td class="colLast">
			
				The <code>&lt;o:treeInsertChildren&gt;</code> represents the insertion point for the grand children. This is in turn
				further interpreted as <code>&lt;o:treeNode&gt;</code>.
			
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="resourceInclude.html">resourceInclude</a></b></td><td class="colLast">
			This component includes the output from a resource located at the given path. This path can
			not extend outside of the current Servlet context. A resource is either a Servlet or a JSP
			page.
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="deferredScript.html">deferredScript</a></b></td><td class="colLast">
			
				<strong>DeferredScript</strong> is a component which defers the loading of the given script resource to the window
				load event. In other words, the given script resource is only loaded when the window is really finished with loading.
				So, the enduser can start working with the webpage without waiting for the additional scripts to be loaded. Usually,
				it are those kind of scripts which are just for progressive enhancement and thus not essential for the functioning
				of the webpage.
				<p>
				This will give bonus points with among others the Google PageSpeed tool, on the contrary to placing the script at
				bottom of body, or using <code>defer="true"</code> or even <code>async="true"</code>.
			
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="onloadScript.html">onloadScript</a></b></td><td class="colLast">
			
				<strong><code>o:onloadScript</code></strong> is an extension to <code>&lt;h:outputScript&gt;</code> which will be executed in the
				end of the HTML body (thus when all HTML elements are initialized in the HTML DOM tree) and will re-execute its
				script body on every ajax request. This is particularly useful if you want to re-execute a specific helper script
				to manipulate the HTML DOM tree, such as (re-)adding fancy tooltips, performing highlights, etcetera, also after
				changes in the HTML DOM tree on ajax responses.
				<p>
				You can put it anywhere in the view, it will always be relocated to the end of body.
				<pre>
&lt;o:onloadScript&gt;alert('OnloadScript is invoked!');&lt;/o:onloadScript&gt;
				</pre>
			
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="highlight.html">highlight</a></b></td><td class="colLast">
			
				<strong><code>o:highlight</code></strong> is a helper component which highlights all invalid <code>UIInput</code> components and the
				associated labels by adding an error style class to them. Additionally, it by default focuses the first invalid 
				<code>UIInput</code> component. The <code>&lt;o:highlight /&gt;</code> component can be placed anywhere in the view, as 
				long as there's only one of it.	Preferably put it somewhere in the master template for forms.
				<pre>
&lt;h:form&gt;
  &lt;h:inputText value="#{bean.input1}" required="true" /&gt;
  &lt;h:inputText value="#{bean.input1}" required="true" /&gt;
  &lt;h:commandButton value="Submit" action="#{bean.submit}" /&gt;
&lt;/h:form&gt;
&lt;o:highlight /&gt;
				</pre>
				<p>
				The default error style class name is <code>error</code>. You need to specify a CSS style associated with the class
				yourself. For example,
				<pre>
label.error {
  color: #f00;
}
input.error, select.error, textarea.error {
  background-color: #fee;
}
				</pre>
				<p>
				You can override the default error style class by the <code>styleClass</code> attribute:
				<pre>
&lt;o:highlight styleClass="invalid" /&gt;
				</pre>
				<p>
				You can disable the default focus on the first invalid input element setting the <code>focus</code> attribute.
				<pre>
&lt;o:highlight styleClass="invalid" focus="false" /&gt;
				</pre>
			
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="conditionalComment.html">conditionalComment</a></b></td><td class="colLast">
			
				<p><strong>o:conditionalComment</strong> is an <code>UIComponent</code> which renders a conditional comment. Conditional
				comments are an IE specific feature which enables the developer to (out)comment blocks of HTML depending on whether
				the client is using IE and if so even which version. They are often seen in combination with CSS stylesheets like so:
				<pre>
&lt;!--[if lte IE 7]&gt;
  &lt;link rel="stylesheet" href="ie6-ie7.css" /&gt;
&lt;![endif]--&gt;
				</pre>
				<p>However, Facelets renders them HTML-escaped and if <code>javax.faces.FACELETS_SKIP_COMMENTS</code> context param is
				set to <code>true</code> then it will even not be rendered at all. You would need to workaround this with an ugly
				<code>&lt;h:outputText escape="false"&gt;</code>.
				<pre>
&lt;h:outputText value="&amp;lt;!--[if lte IE 7]&amp;gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;ie6-ie7.css&amp;quot; /&amp;gt;&amp;lt;![endif]--&amp;gt;" escape="false" /&gt;
				</pre>
				<p>This component is designed to solve this problem.
				<pre>
&lt;o:conditionalComment if="lte IE 7"&gt;
  &lt;link rel="stylesheet" href="ie6-ie7.css" /&gt;
&lt;/o:conditionalComment&gt;
				</pre>
				<p>Note that you cannot use this with <code>&lt;h:outputStylesheet&gt;</code> as it would implicitly be relocated as
				direct child of <code>&lt;h:head&gt;</code>.
			
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="validateAll.html">validateAll</a></b></td><td class="colLast">
			
				<strong><code>o:validateAll</code></strong> validates validates if ALL of the given <code>UIInput</code>
				components have been filled out. The default message is
				<blockquote>{0}: Please fill out all of those fields</blockquote>
				<hr>
				<h3>General usage of all multiple field validators</h3>
				<p>
				This validator must be placed inside the same <code>UIForm</code> as the <code>UIInput</code> components
				in question. The <code>UIInput</code> components must be referenced by a space separated collection of
				their client IDs in the <code>components</code> attribute. This validator can be placed anywhere in the
				form, but keep in mind that the components will be validated in the order as they appear in the form.
				So if this validator is been placed before all of the components, then it will be executed before any of
				the component's own validators. If this validator fails, then the component's own validators will not be
				fired. If this validator is been placed after all of the components, then it will be executed after any
				of the component's own validators. If any of them fails, then this validator will not be exeucted. It
				is not recommended to put this validator somewhere in between the referenced components as the resulting
				behaviour may be confusing. Put this validator either before or after all of the components, depending
				on how you would like to prioritize the validation.
				<pre>
&lt;o:validateMultipleFields id="myId" components="foo bar baz" /&gt;
&lt;h:message for="myId" /&gt;
&lt;h:inputText id="foo" /&gt;
&lt;h:inputText id="bar" /&gt;
&lt;h:inputText id="baz" /&gt;
				</pre>
				<p>
				By default, in an invalidating case, all of the referenced components will be marked invalid and a faces message will
				be added on the client ID of this validator component. The default message can be changed by the <code>message</code>
				attribute. Any "{0}" placeholder in the message will be substituted with a comma separated string of labels of the
				referenced input components.
				<pre>
&lt;o:validateMultipleFields components="foo bar baz" message="{0} are wrong!" /&gt;
				</pre>
				<p>
				You can use <code>invalidateAll="false"</code> to mark only those components which are actually invalid as invalid.
				In case of for example "input all" or "input all or none" validation, that would be only the fields which are left
				empty.
				<pre>
&lt;o:validateMultipleFields components="foo bar baz" message="{0} are wrong!" invalidateAll="false" /&gt;
				</pre>
				<p>
				The faces message can also be shown for all of the referenced components using <code>showMessageFor="@all"</code>.
				<pre>
&lt;o:validateMultipleFields components="foo bar baz" message="This is wrong!" showMessageFor="@all" /&gt;
&lt;h:inputText id="foo" /&gt;
&lt;h:message for="foo" /&gt;
&lt;h:inputText id="bar" /&gt;
&lt;h:message for="bar" /&gt;
&lt;h:inputText id="baz" /&gt;
&lt;h:message for="baz" /&gt;
				</pre>
				<p>
				The faces message can also be shown for only the invalidated components using <code>showMessageFor="@invalid"</code>.
				<pre>
&lt;o:validateMultipleFields components="foo bar baz" message="This is wrong!" showMessageFor="@invalid" /&gt;
				</pre>
				<p>
				The faces message can also be shown as global message using <code>showMessageFor="@global"</code>.
				<pre>
&lt;o:validateMultipleFields components="foo bar baz" message="This is wrong!" showMessageFor="@global" /&gt;
				</pre>
				<p>
				The faces message can also be shown for specific components referenced by a space separated collection of their
				client IDs in <code>showMessageFor</code> attribute.
				<pre>
&lt;o:validateMultipleFields components="foo bar baz" message="This is wrong!" showMessageFor="foo baz" /&gt;
				</pre>
				<p>
				The <code>showMessageFor</code> attribute defaults to <code>@this</code>.
				<p>
				The validator can be disabled by the <code>disabled</code> attribute. It accepts a request based EL expression.
				<pre>
&lt;o:validateMultipleFields components="foo bar baz" disabled="#{param.validationDisabled}" /&gt;
				</pre>
				<p>
				There is a read-only <code>validationFailed</code> attribute which can be used to determine if the validation by
				this component has failed.
				<pre>
&lt;o:validateMultipleFields id="myId" binding="#{myId}" components="foo bar baz" /&gt;
&lt;h:panelGroup rendered="#{myId.validationFailed}"&gt;
	Validation has failed! &lt;h:message for="myId" /&gt;
&lt;/h:panelGroup&gt;
				</pre>
			
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="validateAllOrNone.html">validateAllOrNone</a></b></td><td class="colLast">
			
				<strong><code>o:validateAllOrNone</code></strong> validates validates if at least ALL of the given <code>UIInput</code>
				components have been filled out or that NONE of the given <code>UIInput</code> components have been
				filled out. The default message is
				<blockquote>{0}: Please fill out all or none of those fields</blockquote>
				<p>
				For general usage instructions, refer <code>validateAll</code> tag documentation.
			
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="validateOneOrMore.html">validateOneOrMore</a></b></td><td class="colLast">
			
				<strong><code>o:validateOneOrMore</code></strong> validates if at least ONE of the given <code>UIInput</code>
				components has been filled out. The default message is
				<blockquote>{0}: Please fill out at least one of those fields</blockquote>
				<p>
				For general usage instructions, refer <code>validateAll</code> tag documentation.
				The <code>invalidateAll</code> attribute has no effect on this component and is therefore not listed.
			
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="validateOne.html">validateOne</a></b></td><td class="colLast">
			
				<strong><code>o:validateOne</code></strong> validates if ONLY ONE of the given <code>UIInput</code>
				components has been filled out. The default message is
				<blockquote>{0}: Please fill out only one of those fields</blockquote>
				<p>
				For general usage instructions, refer <code>validateAll</code> tag documentation.
				The <code>invalidateAll</code> attribute has no effect on this component and is therefore not listed.
			
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="validateOneOrNone.html">validateOneOrNone</a></b></td><td class="colLast">
			
				<strong><code>o:validateOneOrNone</code></strong> validates if ONLY ONE of the given <code>UIInput</code> components has been filled
				out or that NONE of the given <code>UIInput</code> components have been filled out. The default message is
				<blockquote>{0}: Please fill out only one or none of those fields</blockquote>
				<p>
				For general usage instructions, refer <code>validateAll</code> tag documentation.
				The <code>invalidateAll</code> attribute has no effect on this component and is therefore not listed.
			
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="validateEqual.html">validateEqual</a></b></td><td class="colLast">
			
				<strong><code>o:validateEqual</code></strong> validates if ALL of the given <code>UIInput</code> components have the
				same value. The default message is
				<blockquote>{0}: Please fill out the same value for all of those fields</blockquote>
				<p>
				For general usage instructions, refer <code>validateAll</code> tag documentation.
				The <code>invalidateAll</code> attribute has no effect on this component and is therefore not listed.
			
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="validateUnique.html">validateUnique</a></b></td><td class="colLast">
			
				<strong><code>o:validateUnique</code></strong> validates if ALL of the given <code>UIInput</code> components have an
				unique value. The default message is
				<blockquote>{0}: Please fill out an unique value for all of those fields</blockquote>
				<p>
				For general usage instructions, refer <code>validateAll</code> tag documentation.
				The <code>invalidateAll</code> attribute has no effect on this component and is therefore not listed.
			
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="validateOrder.html">validateOrder</a></b></td><td class="colLast">
			
				<strong>ValidateOrder</strong> validates if the values of the given <code>UIInput</code> components as specified in
				the <code>components</code> attribute are in the order as specified by the <code>type</code> attribute which accepts
				the following values:
				<ul>
				<li><code>lt</code> (default): from least to greatest, without duplicates.</li>
				<li><code>lte</code>: from least to greatest, allowing duplicates (equal values next to each other).</li>
				<li><code>gt</code>: from greatest to least, without duplicates.</li>
				<li><code>gte</code>: from greatest to least, allowing duplicates (equal values next to each other).</li>
				</ul>
				The default message is
				<blockquote>{0}: Please fill out the values of all those fields in order</blockquote>
				<p>
				For general usage instructions, refer <code>validateAll</code> tag documentation.
				The <code>invalidateAll</code> attribute has no effect on this component and is therefore not listed.
				<p>
				This validator has the additional requirement that the to-be-validated values must implement <code>Comparable</code>.
				This validator throws an <code>IllegalArgumentException</code> when one or more of the values do not implement it.
			
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="validateMultiple.html">validateMultiple</a></b></td><td class="colLast">
			
				<strong>ValidateMultiple</strong> allows the developer to validate multiple fields by a custom validator method:
				<pre>
&lt;o:validateMultiple id="myId" components="foo bar baz" validator="#{bean.validateValues}" /&gt;
&lt;h:message for="myId" /&gt;
&lt;h:inputText id="foo" /&gt;
&lt;h:inputText id="bar" /&gt;
&lt;h:inputText id="baz" /&gt;
				</pre>
				<pre>
public boolean validateValues(FacesContext context, List&lt;UIInput&gt; components, List&lt;Object&gt; values) {
	// ...
}
				</pre>
				<p>Or by a managed bean instance which implements the <code>MultiFieldValidator</code> interface:
				<pre>
&lt;o:validateMultiple id="myId" components="foo bar baz" validator="#{validateValuesBean}" /&gt;
&lt;h:message for="myId" /&gt;
&lt;h:inputText id="foo" /&gt;
&lt;h:inputText id="bar" /&gt;
&lt;h:inputText id="baz" /&gt;
				</pre>
				<pre>
@ManagedBean
@RequestScoped
public class ValidateValuesBean implements MultiFieldValidator {
	@Override
	boolean validateValues(FacesContext context, List&lt;UIInput&gt; components, List&lt;Object&gt; values) {
		// ...
	}
}
				</pre>
			
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="validator.html">validator</a></b></td><td class="colLast">
			
				The <code>&lt;o:validator&gt;</code> basically extends the <code>&lt;f:validator&gt;</code> tag family with the
				possibility to evaluate the value expression in all attributes on a per request basis instead of on a per view
				build time basis. This allows the developer to change the attributes on a per request basis, such as the
				<code>disabled</code> attribute.
				<pre>
&lt;o:validator validatorId="someValidatorId" disabled="#{param.disableValidation}" /&gt;
				</pre>
				<p>Note that not all available attributes are listed. This depends on the validator you're specifying.
				When you specify for example the standard <code>&lt;f:validateLongRange&gt;</code> by
				<code>validatorId="javax.faces.LongRange"</code>, then you'll be able to use all its attributes such as
				<code>minimum</code> and <code>maximum</code> as per its documentation, but then with the possibility to supply
				request based value expressions.
				<pre>
&lt;o:validator validatorId="javax.faces.LongRange" minimum="#{item.minimum}" maximum="#{item.maximum}" /&gt;
				</pre>
			
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="converter.html">converter</a></b></td><td class="colLast">
			
				The <code>&lt;o:converter&gt;</code> basically extends the <code>&lt;f:converter&gt;</code> tag family with the
				possibility to evaluate the value expression in all attributes on a per request basis instead of on a per view
				build time basis. This allows the developer to change the attributes on a per request basis.
				<p>
				When you specify for example the standard <code>&lt;f:convertDateTime&gt;</code> by
				<code>converterId="javax.faces.DateTime"</code>, then you'll be able to use all its attribuces such as
				<code>pattern</code> and <code>locale</code> as per its documentation, but then with the possibility to supply
				request based value expressions.
				<pre>
&lt;o:converter converterId="javax.faces.DateTime" pattern="#{item.pattern}" locale="#{item.locale}" /&gt;
				</pre>
			
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="inputFile.html">inputFile</a></b></td><td class="colLast">
			
				The <code>&lt;o:inputFile&gt;</code> is a component that extends the standard <code>&lt;h:inputFile&gt;</code> and
				adds support for <code>multiple</code>, <code>directory</code> and <code>accept</code> attributes. Additionally, it
				makes sure that the value of HTML file input element is never rendered. The standard <code>&lt;h:inputFile&gt;</code>
				renders <code>Part#toString()</code> to it which is unnecessary.
			
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="viewParam.html">viewParam</a></b></td><td class="colLast">
				
					<strong>ViewParameter</strong> is a component that extends the standard <code>UIViewParameter</code> and provides a
					stateless mode of operation and fixes the issue wherein null model values are converted to empty string parameters
					in query string (e.g. when <code>includeViewParams=true</code>) and the (bean) validation never being triggered
					when the parameter is completely absent in query string, causing e.g. <code>@NotNull</code> to fail.
					<p>
					The standard UIViewParameter implementation calls the model setter again after postback. This is not always desired
					when being bound to a view scoped bean and can lead to performance problems when combined with an expensive converter.
					To solve this, this component by default stores the submitted value as a component property instead of in the model
					(and thus in the view state in case the binding is to a view scoped bean).
					<p>
					The standard UIViewParameter implementation calls the converter regardless of whether the evaluated model value is
					<code>null</code> or not. As converters by specification return an empty string in case of <code>null</code> value,
					this is being added to the query string as an empty parameter. This is not desired.
					<p>
					The standard UIViewParameter implementation uses an internal "is required" check when the submitted value is
					<code>null</code>, hereby completely bypassing the standard <code>UIInput</code> validation, including any bean
					validation annotations and even the <code>PreValidateEvent</code> and <code>PostValidateEvent</code> events. This is not
					desired.
					<p>
					You can use it the same way as <code>&lt;f:viewParam&gt;</code>, you only need to change <code>f:</code> to
					<code>o:</code>.
				
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="viewAction.html">viewAction</a></b></td><td class="colLast">
				
					The <code>&lt;o:viewAction&gt;</code> is a component that extends the standard <code>&lt;f:viewAction&gt;</code> and
					changes the <code>if</code> attribute to be evaluated during <code>INVOKE_APPLICATION</code> phase instead of the
					<code>APPLY_REQUEST_VALUES</code> phase. This allows developers to let the <code>if</code> attribute check the
					converted and validated model values before performing the view action, which results in much more intuitive behavior.
					<p>
					In below example, the <code>FooConverter</code> may convert a non-null parameter to <code>null</code> without causing
					a validation or conversion error, and the intent is to redirect the current page to <code>otherpage.xhtml</code> when
					the converted result is <code>null</code>.
					<pre>
					&lt;f:viewParam name="foo" value="#{bean.foo}" converter="fooConverter" /&gt;
					&lt;f:viewAction action="otherpage" if="#{bean.foo eq null}" /&gt;
					</pre>
					<p>
					This is however not possible with standard <code>&lt;f:viewAction&gt;</code> as it evaluates the <code>if</code>
					attribute already before the conversion has taken place. This component solves that by postponing the evaluation of
					the <code>if</code> attribute to the <code>INVOKE_APPLICATION</code> phase.
					<pre>
					&lt;f:viewParam name="foo" value="#{bean.foo}" converter="fooConverter" /&gt;
					&lt;o:viewAction action="otherpage" if="#{bean.foo eq null}" /&gt;
					<p>
					Only when you set <code>immediate="true"</code>, then it will behave the same as the standard
					<code>&lt;f:viewAction&gt;</code>.
 				
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="resolveComponent.html">resolveComponent</a></b></td><td class="colLast">
			
				<strong>ResolveComponent</strong> is a utility component via which a component can be looked up by its ID and
 				a reference to it put in either the "facelet scope" (default) or the request scope.
			
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="moveComponent.html">moveComponent</a></b></td><td class="colLast">
			
				<strong>MoveComponent</strong> is a utility component via which a components and behaviors can be moved to 
 				a target component at various ways.
			
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="methodParam.html">methodParam</a></b></td><td class="colLast">
			
				<strong><code>o:methodParam</code></strong> is a tag handler that can be used to pass a method expression
				into a Facelets tag.
				<p>
				By default this is not possible, and the expression that's intended to be a method expression will be created and
				made available as a value expression. This handler should be placed inside a Facelets tag as follows:
				<pre>
&lt;ui:composition
	xmlns="http://www.w3.org/1999/xhtml"
	xmlns:ui="http://java.sun.com/jsf/facelets"
	xmlns:h="http://java.sun.com/jsf/html"
	xmlns:o="http://omnifaces.org/ui"
&gt;
	&lt;o:methodParam name="method" value="#{action}"/&gt;

	&lt;h:commandButton value="test" action="#{method}" /&gt;

&lt;/ui:composition&gt;
				</pre>
				<p>
				Assuming the above is a tag called <code>actionmethod</code> in the namespace <code>test</code>, a method can be passed into it
				as follows:
				<pre>
&lt;test:actionmethod action="#{methodParamBean.doAction}" /&gt;
				</pre>
				<p>
				In case a method with no parameters is passed that is to be used as an action listener with no parameters, then the component
				using this method unfortunely has to be wrapped by a component that puts the method in request scoped (with nested visibility),
				e.g. by using <code>ui:repeat</code> as follows:
				<pre>
&lt;ui:repeat var="method" value="#{method}"&gt;
	&lt;h:commandButton value="test" actionListener="#{method}" /&gt;
&lt;/ui:repeat&gt;
				</pre>
				<p>
				Using modern EL implementations, this is not needed in case the EL expression references the method using explicit parenthesis,
				e.g. <code>#{methodParamBean.doAction()}</code>
			
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="tagAttribute.html">tagAttribute</a></b></td><td class="colLast">
			
				Declare a tagfile attribute. This should in nested tags shield same attributes set on parent tags.
				This also offers the possibility to declare a default value.
			
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="componentIdParam.html">componentIdParam</a></b></td><td class="colLast">
				
					<strong>ComponentIdParam</strong> is a component that allows component ids to be provided as request parameters
 					causing only components with matching ids to be rendered.
 					<p>
 					Both simple component ids as well as client ids are supported. Components can be rendered without their parents
 					having to be rendered. As such, e.g. single rows appearing in a table can be rendered without any of the
 					surrounding markup appearing in the response.
 					<p>
 					The intended usage of this component is to allow client-side scripts to request markup for specific components
 					via a GET request (as opposed to AJAX based post-backs).
					<p>
					This component is used in the same way view parameters are and needs to be put into the metadata section of a
					Facelet.
				
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="outputFormat.html">outputFormat</a></b></td><td class="colLast">
			
				<strong>OutputFormat</strong> is a component that extends the standard <code>HtmlOutputFormat</code> and provides support
				for capturing the output and exposing it into the request scope by the variable name as specified by the
				<code>var</code> attribute.
			 
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="outputLabel.html">outputLabel</a></b></td><td class="colLast">
			
				<strong><code>o:outputLabel</code></strong> is a component that extends the standard outputLabel and provides extra support for
	 			automatically setting its value as the label of the component identified by its <code>for</code> attribute.
				<p>
				It renders an HTML "label" element. If a "for" attribute is specified, the component specified by the value of the "for"
				attribute is queried for its client id, which is then rendered as the value of the "for" attribute of the HTML label element.
			 
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="graphicImage.html">graphicImage</a></b></td><td class="colLast">
			
				The <code>&lt;o:graphicImage&gt;</code> is a component that extends the standard <code>&lt;h:graphicImage&gt;</code>
				with support for referencing an <code>InputStream</code> or <code>byte[]</code> property in <code>value</code> attribute.
				This property must point to a <strong>stateless</strong> <code>@ApplicationScoped</code> bean (both JSF and CDI
				scopes are supported).
			 
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="url.html">url</a></b></td><td class="colLast">
			
				The <code>&lt;o:url&gt;</code> is a component which renders the given JSF view ID as a bookmarkable URL with support
				for exposing it into the request scope by the variable name as specified by the <code>var</code> attribute instead of
				rendering it. This component also supports adding query string parameters to the URL via nested
				<code>&lt;f:param&gt;</code> and <code>&lt;o:param&gt;</code>.
			 
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="form.html">form</a></b></td><td class="colLast">
			
				<strong>Form</strong> is a component that extends the standard <code>UIForm</code> and provides a way to keep view
				parameters in the request URL after a post-back and offers in combination with the
				<code>&lt;o:ignoreValidationFailed&gt;</code> tag on an <code>UICommand</code> component the possibility to ignore
				validation failures so that the invoke action phase will be executed anyway.
			 
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="cache.html">cache</a></b></td><td class="colLast">
		   	
		   		<strong>Cache</strong> is a component that initially renders the output of its children into a buffer
		   		instead of to the response. This output is then inserted into a cache and on subsequent requests the
		   		content retrieved from the cache is used.
		   		<p>
		   		By default the viewid concatenated to the component id via an underscore is used as the cache key.
		   		<p>
		   		Note that this component <strong>does not</strong> support a cache loader and locking mechanism. This mean several
		   		simultaenous page requests may render the same content and it's undetermined which of those will end up being cached.
		   		<p>
		   		An optional caching provider (see below) can be set to control the caching implementation that is used for the actual caching.
		   		If no such provider is installed, a default caching implementation is used that's based on
		   		<a href="https://github.com/ben-manes/concurrentlinkedhashmap">https://github.com/ben-manes/concurrentlinkedhashmap</a> in case
		   		a maximum cache capacity is set, or on a plain ConcurrentMap if no capacity is set.
		   		<hr>
				<h3>Setting a custom caching provider</h3>
				<p>A custom caching provider can be set by using the <code>org.omnifaces.CACHE_PROVIDER</code> context
				parameter in web.xml to point to an implementation of <code>org.omnifaces.component.output.cache.CacheProvider</code>.
				For example:
				<pre>
&lt;context-param&gt;
	&lt;param-name&gt;org.omnifaces.CACHE_PROVIDER&lt;/param-name&gt;
	&lt;param-value&gt;com.example.MyProvider&lt;/param-value&gt;
&lt;/context-param&gt;
				</pre>
				<p>
				The default provider, <code>org.omnifaces.component.output.cache.DefaultCacheProvider</code> can be used as an
				example.
				<hr>
				<h3>Global settings</h3>
				<p>For the default provider, the maximum capacity and the default time to live can be specified for the
				supported scopes "session" and "application". If the maximum capacity is reached, an entry will be
				evicted following a least recently used policy. The default time to live specifies for how long
				entries are considered to be valid. A value for the <code>time</code> attribute on this component
				will override this global default time to live. The following context parameters can be used in web.xml:
				<p>
				<table>
				<tr>
 				<td nowrap><code>org.omnifaces.CACHE_SETTING_APPLICATION_MAX_CAPACITY</code></td>
				<td>Sets the maximum number of elements that will be stored per web module (application scope). Default: no limit</td>
 				</tr>
 				<tr>
 				<td nowrap><code>org.omnifaces.CACHE_SETTING_SESSION_MAX_CAPACITY</code></td>
				<td>Sets the maximum number of elements that will be stored per session. Default: no limit</td>
 				</tr>
 				<tr>
 				<td nowrap><code>org.omnifaces.CACHE_SETTING_APPLICATION_TTL</code></td>
				<td>Sets the maximum amount of time in seconds that cached content is valid for the application scope.
				Can be overriden by individal cache components. Default: no limit</td>
 				</tr>
 				<tr>
 				<td nowrap><code>org.omnifaces.CACHE_SETTING_SESSION_TTL</code></td>
				<td>Sets the maximum amount of time in seconds that cached content is valid for the session scope.
				Can be overriden by individal cache components. Default: no limit</td>
 				</tr>
 				<tr>
 				<td nowrap><code>org.omnifaces.CACHE_INSTALL_BUFFER_FILTER</code></td>
				<td>Boolean that when true installs a Servlet Filter (Servlet 3.0+ only) that works in conjunction with the <code>useBuffer</code> attribute of the Cache component
					to enable an alternative way to grab the content that needs to be cached. This is a convenience setting that is a short-cut
					for installing the <code>org.omnifaces.servlet.BufferedHttpServletResponse</code> filter manually. If more finegrained control
					is needed regarding which place in the filter chain the filter appears and which resources it exactly filters, this setting
					should not be used and the mentioned filter should be manually configured. Default: <code>false</code>)
				 </td>
 				</tr>
 				</table>
			
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="cacheValue.html">cacheValue</a></b></td><td class="colLast">
			
				Tag handler (runs at tree build-time) that makes a value expression available under the given name that caches its value.
				Although the value expressions scope is that of the entire Facelet in which this tag appears, the value it self is cached
				using the parent Cache component.
				<p>
				This means that if the parent <code>o:Cache</code> component clears its cache (e.g. because of time to live expiration), the value cached
				by this value expression will be automatically cleared as well.
				<p>
				The direct parent of this component <b>MUST</b> be <code>o:Cache</code> or a potential subclass of the associated UIComponent.
				It's an error to have any other kind of parent.
				<p>
				The intended use of this is to explicitly cache a value expression that is used by one of the component children of <code>o:Cache</code>,
				so that even after a post-back (where the cached markup is of nu use) the original value expression will not be re-evaluated.
			
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="importConstants.html">importConstants</a></b></td><td class="colLast">
			
				<p>The <code>&lt;o:importConstants&gt;</code> allows the developer to have a mapping of all constant field values of
				the given type in the request scope. The constant field values are those public static final fields. This works for
				classes, interfaces and enums. For example:
				<pre>
public class Foo {
	public static final String FOO1 = "foo1";
	public static final String FOO2 = "foo2";
}

public interface Bar {
	public static final String BAR1 = "bar1";
	public static final String BAR2 = "bar2";
}

public enum Baz {
	BAZ1, BAZ2;
}
				</pre>
				<p>The constant field values of the above types can be mapped into the request scope as follows:
				<pre>
&lt;o:importConstants type="com.example.Foo" /&gt;
&lt;o:importConstants type="com.example.Bar" /&gt;
&lt;o:importConstants type="com.example.Baz" var="Bazzz" /&gt;
...
#{Foo.FOO1}, #{Foo.FOO2}, #{Bar.BAR1}, #{Bar.BAR2}, #{Bazzz.BAZ1}, #{Bazzz.BAZ2}
				</pre>
				<p>The map is by default stored in the request scope by the simple name of the type as variable name. You can override
				this by explicitly specifying the <code>var</code> attribute, as demonstrated for <code>com.example.Baz</code> in
				the above example.
				<p>
				The resolved constants are by reference stored in the cache to improve retrieving performance.
			
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="importFunctions.html">importFunctions</a></b></td><td class="colLast">
			
				<p>The <code>&lt;o:importFunctions&gt;</code> allows the developer to have access to all functions of the given
				fully qualified name of a type in the Facelet scope using the usual EL functions syntax without the need to register them
				in <code>.taglib.xml</code> file. The functions are those <code>public static</code> methods with a
				<strong>non</strong>-<code>void</code> return type. For example:
				<pre>
&lt;o:importFunctions type="java.lang.Math" var="m" /&gt;
&lt;o:importFunctions type="org.omnifaces.util.Faces" /&gt;
...
#{m:abs(-10)}
#{m:max(bean.number1, bean.number2)}
...
&lt;base href="#{Faces:getRequestBaseURL()}" /&gt;
				</pre>
				<p>The functions prefix becomes by default the simple name of the type. You can override this by explicitly
				specifying the <code>var</code> attribute. If there are multiple function methods with exactly the same name, then
				the one with the least amount of parameters will be used. If there are multiple function methods with exactly the
				same name and amount of parameters, then the choice is unspecified (technically, JVM-dependent) and should not be
				relied upon. So if you absolutely need to differentiate functions in such case, give them each a different name.
				<p>Note that the colon <code>:</code> operator to invoke the method is as required by EL functions spec. It's by
				design not easily possible to change it to the period <code>.</code> operator. Also note that in case of
				<code>org.omnifaces.util.Faces</code> it's considered poor practice if the same functionality is already available
				through the implicit EL variables <code>#{facesContext}</code>, <code>#{view}</code>, <code>#{request}</code>, etc
				such as <code>#{request.contextPath}</code> which should be preferred over
				<code>#{Faces:getRequestContextPath()}</code>.
				<p>
				The resolved functions are by reference stored in the cache to improve retrieving performance.
			
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="ignoreValidationFailed.html">ignoreValidationFailed</a></b></td><td class="colLast">
			
				The <code>&lt;o:ignoreValidationFailed&gt;</code> allows the developer to ignore validation failures when
				executing an <code>UICommand</code> action. This taghandler must be placed inside an <code>UICommand</code> component and the
				parent <code>UIForm</code> must be an <code>&lt;o:form&gt;</code>.
				<p>
				Any validation errors will be ignored and thus not be displayed. Note that the model values will (obviously) only be
				updated for components which have passed the validation.
			
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="skipValidators.html">skipValidators</a></b></td><td class="colLast">
			
				The <code>&lt;o:skipValidators&gt;</code> allows the developer to skip validators when
				executing a submit. This taghandler must be placed inside the component that invokes the submit, may be an 
				<code>UICommand</code> (both ajaxified or not) as well as any <code>ClientBehaviorHolder</code> (ajax enabled) component.
				<p>
				Validation will happen, but no validator will be executed since they will be temporary detached from processed components. 
				Conversion errors could still occur. Note that the model values will be updated for all processed components.
			
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="enableRestorableView.html">enableRestorableView</a></b></td><td class="colLast">
			
				The <code>&lt;o:enableRestorableView&gt;</code> instructs the view handler to recreate the entire view whenever the
				view has been expired, i.e. whenever <code>#restoreView(FacesContext, String)</code> returns <code>null</code> and the
				current request is a postback. This effectively prevents <code>ViewExpiredException</code> on the view. This tag needs to
				be placed in <code>&lt;f:metadata&gt;</code> of the view.
				<p>
				There are however technical design limitations: please consult the javadoc for details. To the point, the bean associated
				with the view has to be exclusively request scoped in order to properly recreate the same view.
			
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="validateBean.html">validateBean</a></b></td><td class="colLast">
			
				The <code>&lt;o:validateBean&gt;</code> allows the developer to control bean validation groups on a
				per-<code>UICommand</code> or <code>UIInput</code> component basis. Usage example:
				<pre>
&lt;h:commandButton&gt;
	&lt;o:validateBean groups="javax.validation.groups.Default,com.example.MyGroup"/&gt;
&lt;/h:commandButton&gt;
				</pre>
			
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="validateUniqueColumn.html">validateUniqueColumn</a></b></td><td class="colLast">
			
				<strong>ValidateUniqueColumn</strong> validates if the given <code>UIInput</code> component in an <code>UIData</code> component
				has an unique value throughout all rows, also those not visible by pagination. This validator works directly on the
				data model and may therefore not work as expected if the data model does not represent <strong>all</strong> available
				rows of the <code>UIData</code> component (e.g. when there's means of lazy loading).
				<p>
				The default message is
				<blockquote>{0}: Please fill out an unique value for the entire column. Duplicate found in row {1}</blockquote>
				<p>
				Usage example:
				<pre>
&lt;h:dataTable value="#{bean.items}" var="item"&gt;
  &lt;h:column&gt;
	&lt;h:inputText value="#{item.value}"&gt;
	  &lt;o:validateUniqueColumn /&gt;
	&lt;/h:inputText&gt;
  &lt;/h:column&gt;
&lt;/h:dataTable&gt;
				</pre>
				<p>
				In an invalidating case, only the first row on which the value is actually changed (i.e. the value change event has
				been fired on the input component in the particular row) will be marked invalid and a faces message will be added
				on the client ID of the input component in the particular row. The default message can be changed by the
				<code>message</code> attribute. Any "{0}" placeholder in the message will be substituted with the label of the
				input component. Any "{1}" placeholder in the message will be substituted with the 1-based row index of the data
				model. Note that this does not take pagination into account and that this needs if necessary to be taken care of in
				the custom message yourself.
				<pre>
&lt;o:validateUniqueColumn message="Duplicate value!" /&gt;
				</pre>
			
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="massAttribute.html">massAttribute</a></b></td><td class="colLast">
			
				The <strong>&lt;o:massAttribute&gt;</strong> sets an attribute of the given name and value on all nested components,
				if they don't already have an attribute set. On boolean attributes like <code>disabled</code>, <code>readonly</code>
				and <code>rendered</code>, any literal (static) attribute value will be ignored and overridden. Only if they have
				already a value expression <code>#{...}</code> as attribute value, then it won't be overridden. This is a technical
				limitation specifically for boolean attributes as they don't default to <code>null</code>.
				<p>
				For example, the following setup
				<pre>
&lt;o:massAttribute name="disabled" value="true"&gt;
	&lt;h:inputText id="input1" /&gt;
	&lt;h:inputText id="input2" disabled="true" /&gt;
	&lt;h:inputText id="input3" disabled="false" /&gt;
	&lt;h:inputText id="input4" disabled="#{true}" /&gt;
	&lt;h:inputText id="input5" disabled="#{false}" /&gt;
&lt;/o:massAttribute&gt;
				</pre>
				will set the <code>disabled="true"</code> attribute in <code>input1</code>, <code>input2</code> and
				<code>input3</code> as those are the only components <strong>without</strong> a value expression on the boolean attribute.
				<p>
				As another general example without booleans, the following setup
				<pre>
&lt;o:massAttribute name="styleClass" value="#{component.valid ? '' : 'error'}"&gt;
	&lt;h:inputText id="input1" /&gt;
	&lt;h:inputText id="input2" styleClass="some" /&gt;
	&lt;h:inputText id="input3" styleClass="#{'some'}" /&gt;
	&lt;h:inputText id="input4" styleClass="#{null}" /&gt;
&lt;/o:massAttribute&gt;
				</pre>
				will only set the <code>styleClass="#{component.valid ? '' : 'error'}"</code> attribute in <code>input1</code> as
				that's the only component on which the attribute is absent.
				Do note that the specified EL expression will actually be evaluated on a per-component basis.
				<p>
				To target a specific component (super)class, use the <code>target</code> attribute. The example below skips labels
				(as that would otherwise fail in the example below because they don't have a <code>valid</code> property):
				<pre>
&lt;o:massAttribute name="styleClass" value="#{component.valid ? '' : 'error'}" target="javax.faces.component.UIInput"&gt;
	&lt;h:outputLabel for="input1" /&gt;
	&lt;h:inputText id="input1" /&gt;
	&lt;h:outputLabel for="input2" /&gt;
	&lt;h:inputText id="input2" /&gt;
	&lt;h:outputLabel for="input3" /&gt;
	&lt;h:inputText id="input3" /&gt;
&lt;/o:massAttribute&gt;
				</pre>
			
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="viewParamValidationFailed.html">viewParamValidationFailed</a></b></td><td class="colLast">
			
				<code>&lt;o:viewParamValidationFailed&gt;</code> allows the developer to handle a view parameter validation failure
				with either a redirect or a HTTP error status, optionally with respectively a flash message or HTTP error message.
				This tag can be placed inside <code>&lt;f:metadata&gt;</code> or <code>&lt;f|o:viewParam&gt;</code>. When placed in
				<code>&lt;f|o:viewParam&gt;</code>, then it will be applied when the particular view parameter has a validation
				error as per <code>UIViewParameter#isValid()</code>. When placed in <code>&lt;f:metadata&gt;</code>, and no one view
				parameter has already handled the validation error via its own  <code>&lt;o:viewParamValidationFailed&gt;</code>,
				then it will be applied when there's a general validation error as per <code>FacesContext#isValidationFailed()</code>.
				<p>
				The <code>sendRedirect</code> attribute uses under the covers <code>Faces#redirect(String, String...)</code> to send the
				redirect, so the same rules as to scheme and leading slash apply here.
				The <code>sendError</code> attribute uses under the covers <code>Faces#responseSendError(int, String)</code> to send the
				error, so you can customize HTTP error pages via <code>&lt;error-page&gt;</code> entries in <code>web.xml</code>,
				otherwise the server-default one will be displayed instead.
				 *
				<h3>f:viewParam required="true" fail</h3>
				<p>
				As a precaution, the <code>&lt;f:viewParam required="true"&gt;</code> has in current Mojarra and MyFaces releases
				(as of now, Mojarra 2.2.7 and MyFaces 2.2.4) a design error. When the parameter is not specified in the query string,
				then it is retrieved as <code>null</code> which causes that an internal <code>isRequired()</code> check is performed
				instead of delegating the check to standard <code>UIInput</code> implementation. This has the consequence that
				<code>PreValidateEvent</code> and <code>PostValidateEvent</code> listeners are never invoked, which the
				<code>&lt;o:viewParamValidationFailed&gt;</code> is actually relying on. This is fixed in
				<code>&lt;o:viewParam</code>.
				 *
				<h3>Examples</h3>
				<p>
				With the example below, when at least one view param is absent, then the client will be returned a HTTP 400 error.
				<pre>
				&lt;f:metadata&gt;
					&lt;o:viewParam name="foo" required="true" /&gt;
					&lt;o:viewParam name="bar" required="true" /&gt;
					&lt;o:viewParamValidationFailed sendError="400" /&gt;
				&lt;/f:metadata&gt;
				</pre>
				<p>
				With the example below, only when the "foo" parameter is absent, then the client will be redirected to "login.xhtml".
				When the "bar" parameter is absent, nothing new will happen. The process will proceed "as usual". I.e. the validation
				error will end up as a faces message in the current view the usual way.
				<pre>
				&lt;f:metadata&gt;
					&lt;o:viewParam name="foo" required="true"&gt;
						&lt;o:viewParamValidationFailed sendRedirect="login.xhtml" /&gt;
					&lt;/o:viewParam&gt;
					&lt;o:viewParam name="bar" required="true" /&gt;
				&lt;/f:metadata&gt;
				</pre>
				<p>
				With the example below, only when the "foo" parameter is absent, regardless of the "bar" or "baz" parameters, then
				the client will be returned a HTTP 401 error. When the "foo" parameter is present, but either "bar" or "baz"
				parameter is absent, then the client will be redirected to "search.xhtml".
				<pre>
				&lt;f:metadata&gt;
					&lt;o:viewParam name="foo" required="true"&gt;
						&lt;o:viewParamValidationFailed sendError="401" /&gt;
					&lt;/o:viewParam&gt;
					&lt;o:viewParam name="bar" required="true" /&gt;
					&lt;o:viewParam name="baz" required="true" /&gt;
					&lt;o:viewParamValidationFailed sendRedirect="search.xhtml" /&gt;
				&lt;/f:metadata&gt;
				</pre>
				<p>
				In a nutshell: when there are multiple <code>&lt;o:viewParamValidationFailed&gt;</code> tags, then they will be
				applied in the same order as they are declared in the view. So, with the example above, the one nested in
				<code>&lt;f|o:viewParam&gt;</code> takes precedence over the one nested in <code>&lt;f:metadata&gt;</code>.
				 *
				<h3>Messaging</h3>
				<p>
				By default, the first occurring faces message on the parent component will be copied, or when there is none, then
				the first occurring global faces message will be copied. When <code>sendRedirect</code> is used, then it will be set
				as a global flash error message. When <code>sendError</code> is used, then it will be set as HTTP status message.
				<p>
				You can override this message by explicitly specifying the <code>message</code> attribute. This is applicable on
				both <code>sendRedirect</code> and <code>sendError</code>.
				<pre>
				&lt;o:viewParamValidationFailed sendRedirect="search.xhtml" message="You need to perform a search." /&gt;
				...
				&lt;o:viewParamValidationFailed sendError="401" message="Authentication failed. You need to login." /&gt;
				</pre>
				 *
				<h3>Design notes</h3>
				<p>
				You can technically nest multiple <code>&lt;o:viewParamValidationFailed&gt;</code> inside the same parent, but this
				is not the documented approach and the behavior is unspecified.
				<p>
				You can <strong>not</strong> change the HTTP status code of a redirect. This is not a JSF limitation, but a HTTP
				limitation. The status code of a redirect will <strong>always</strong> end up the one of the redirected response.
				If you intend to "redirect" with a different HTTP status code, then you should be using <code>sendError</code>
				instead and specify the desired page as <code>&lt;error-page&gt;</code> in <code>web.xml</code>.
			
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="commandScript.html">commandScript</a></b></td><td class="colLast">
			
				<p><strong>CommandScript</strong> is an extension to <code>&lt;h:commandXxx&gt;</code> which generates a JavaScript
				function in the global JavaScript scope which allows the enduser to execute a JSF ajax request by a just function
				call <code>functionName()</code> in the JavaScript context.
				<p>
				The <code>&lt;o:commandScript&gt;</code> component is required to be enclosed in an <code>UIForm</code> component. The
				<code>name</code> attribute is required and it represents the JavaScript function name. The <code>execute</code>
				and <code>render</code> attributes work exactly the same as in <code>&lt;f:ajax&gt;</code>. The <code>onbegin</code>
				and <code>oncomplete</code> attributes must represent (valid!) JavaScript code which will be executed before sending
				the ajax request and after processing the ajax response respectively. The <code>action</code>,
				<code>actionListener</code> and <code>immediate</code> attributes work exactly the same as in
				<code>&lt;h:commandXxx&gt;</code>.
				<p>
				Basic usage example of <code>&lt;o:commandScript&gt;</code> which submits the entire form on click of a plain HTML
				button:
				<pre>
&lt;h:form&gt;
  &lt;h:inputText value="#{bean.input1}" ... /&gt;
  &lt;h:inputText value="#{bean.input2}" ... /&gt;
  &lt;h:inputText value="#{bean.input3}" ... /&gt;
  &lt;o:commandScript name="submitForm" action="#{bean.submit}" render="@form" /&gt;
&lt;/h:form&gt;
&lt;input type="button" value="submit" onclick="submitForm()" /&gt;
				</pre>
				<p>
				Usage example which uses the <code>&lt;o:commandScript&gt;</code> as a poll function which updates every 3 seconds:
				<pre>
&lt;h:form&gt;
  &lt;h:dataTable id="data" value="#{bean.data}" ...&gt;...&lt;/h:dataTable&gt;
  &lt;o:commandScript name="updateData" action="#{bean.reloadData}" render="data" /&gt;
&lt;/h:form&gt;
&lt;h:outputScript target="body"&gt;setInterval(updateData, 3000);&lt;/h:outputScript&gt;
				</pre>
				The component also supports nesting of <code>&lt;f:param&gt;</code>, <code>&lt;f:actionListener&gt;</code> and
				<code>&lt;f:setPropertyActionListener&gt;</code>, exactly like as in <code>&lt;h:commandXxx&gt;</code>. The function
				also supports a JS object as argument which will then end up in the HTTP request parameter map:
				<pre>
functionName({ name1: "value1", name2: "value2" });
				</pre>
				<p>
				With the above example, the parameters are in the action method available as follows:
				<pre>
String name1 = Faces.getRequestParameter("name1"); // value1
String name2 = Faces.getRequestParameter("name2"); // value2
				</pre>
			
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="param.html">param</a></b></td><td class="colLast">
			
				<strong>Param</strong> is a component that extends the standard <code>UIParameter</code> to implement <code>ValueHolder</code>
				and thus support a <code>Converter</code> to convert the supplied value to string, if necessary.
				<p>
				You can use it the same way as <code>&lt;f:param&gt;</code>, you only need to change <code>f:</code> into
				<code>o:</code> to get the extra support for a <code>Converter</code> by usual means via the <code>converter</code>
				attribute of the tag, or the nested <code>&lt;f:converter&gt;</code> tag, or just automatically if a converter is
				already registered for the target class.
				Also, if no value is specified, but children are present, then the encoded output of children will be returned as
				value. This is useful when you want to supply JSF components or HTML as parameter of an unescaped
				<code>&lt;h:outputFormat&gt;</code>. For example,
				<pre>
				&lt;h:outputFormat value="#{bundle.paragraph}" escape="false"&gt;
				  &lt;o:param&gt;&lt;h:link outcome="contact" value="#{bundle.contact}" /&gt;&lt;/o:param&gt;
				&lt;/h:outputFormat&gt;
				</pre>
				<p>with this bundle
				<pre>
				paragraph = Please {0} for more information.
				contact = contact us
				</pre>
				<p>will result in the link being actually encoded as output format parameter value.
			
		</td>
</tr>
<tr class="rowColor">
<td class="colOne"><b><a href="messages.html">messages</a></b></td><td class="colLast">
			
				The <code>&lt;o:messages&gt;</code> is a component that extends the standard <code>&lt;h:messages&gt;</code> with
				the following new features:
				<dl>
				<dt>Multiple <code>for</code> components</dt>
				<dd>Possibility to specify multiple client IDs space separated in the <code>for</code> attribute. The example below
				would only display messages for <code>input1</code> and <code>input3</code>:
				<pre><code>
&lt;h:form&gt;
  &lt;o:messages for="input1 input3" /&gt;
  &lt;h:inputText id="input1" /&gt;
  &lt;h:inputText id="input2" /&gt;
  &lt;h:inputText id="input3" /&gt;
  &lt;h:inputText id="input4" /&gt;
&lt;/h:form&gt;
				</code></pre>
				It can even refer non-input components which in turn contains input components. The example below would only display
				messages for <code>input1</code> and <code>input2</code>:
				<pre><code>
&lt;h:form&gt;
  &lt;o:messages for="inputs" /&gt;
  &lt;h:panelGroup id="inputs"&gt;
	&lt;h:inputText id="input1" /&gt;
	&lt;h:inputText id="input2" /&gt;
  &lt;/h:panelGroup&gt;
  &lt;h:inputText id="input3" /&gt;
  &lt;h:inputText id="input4" /&gt;
&lt;/h:form&gt;
				</code></pre>
				You can even combine them. The example below would only display messages for <code>input1</code>,
				<code>input2</code> and <code>input4</code>.
				<pre><code>
&lt;h:form&gt;
  &lt;o:messages for="inputs input4" /&gt;
  &lt;h:panelGroup id="inputs"&gt;
	&lt;h:inputText id="input1" /&gt;
	&lt;h:inputText id="input2" /&gt;
  &lt;/h:panelGroup&gt;
  &lt;h:inputText id="input3" /&gt;
  &lt;h:inputText id="input4" /&gt;
&lt;/h:form&gt;
				</code></pre>
				</dd>
				<dt>Displaying single message</dt>
				<dd>Show a single custom message whenever the component has received any faces message. This is particularly useful
				when you want to display a global message in case any of the in <code>for</code> specified components has a faces
				message. For example:
				<pre><code>
&lt;o:messages for="form" message="There are validation errors. Please fix them." /&gt;
&lt;h:form id="form"&gt;
  &lt;h:inputText id="input1" /&gt;&lt;h:message for="input1" /&gt;
  &lt;h:inputText id="input2" /&gt;&lt;h:message for="input2" /&gt;
  &lt;h:inputText id="input3" /&gt;&lt;h:message for="input3" /&gt;
&lt;/h:form&gt;
				</code></pre>
				</dd>
				<dt>HTML escaping</dt>
				<dd>Control HTML escaping by the new <code>escape</code> attribute.
				<pre><code>
&lt;o:messages escape="false" /&gt;
				</code></pre>
				Beware of potential XSS attack holes when user-controlled input is redisplayed through messages!
				</dd>
				<dt>Iteration markup control</dt>
				<dd>Control iteration markup fully by the new <code>var</code> attribute which sets the current <code>FacesMessage</code>
				in the request scope and disables the default table/list rendering. For example,
				<pre><code>
&lt;dl&gt;
  &lt;o:messages var="message"&gt;
	&lt;dt&gt;#{message.severity}&lt;/dt&gt;
	&lt;dd title="#{message.detail}"&gt;#{message.summary}&lt;/dd&gt;
  &lt;/o:messages&gt;
&lt;/dl&gt;
				</code></pre>
				Note: the iteration is by design completely stateless. It's therefore not recommended to nest form components inside
				the <code>&lt;o:messages&gt;</code> component. It should be used for pure output only, like as the standard
				<code>&lt;h:messages&gt;</code>. Plain output links are however no problem. Also note that the <code>message</code>
				and <code>escape</code> attributes have in this case no effect. With a single message, there's no point of
				iteration. As to escaping, just use <code>&lt;h:outputText escape="false"&gt;</code> the usual way.
				</dd>
				</dl>
				<p>
				Design notice: the component class is named <code>OmniMessages</code> instead of <code>Messages</code> to avoid
				confusion with the <code>Messages</code> utility class.
			
		</td>
</tr>
<tr class="altColor">
<td class="colOne"><b><a href="socket.html">socket</a></b></td><td class="colLast">
			
				<strong><code>o:socket</code></strong> opens an one-way (server to client) web socket based push conntection
				in client side which can be reached from server side via <code>org.omnifaces.cdi.PushContext</code>
				interface injected in any CDI/container managed artifact via <code>org.omnifaces.cdi.Push</code> annotation.
				<p>
				For detailed usage instructions, see <code>org.omnifaces.cdi.push.Socket</code> javadoc.
			
		</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="bottomNav">
<a name="navbar_bottom"></a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow"></a>
<ul class="navList" title="Navigation">
<li>
<a href="../overview-summary.html">Overview</a>
</li>
<li class="navBarCell1Rev">Library</li>
<li>Tag</li>
<li>
<a href="../help-doc.html">Help</a>
</li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>
<a target="_top" href="../index.html?o/tld-summary.html">
									Frames
								</a>
</li>
<li>
<a href="tld-summary.html" target="_top">No Frames</a>
</li>
</ul>
<ul class="navList" id="alltags_navbar_bottom">
<li>
<a href="../alltags-noframe.html">All Tags</a>
</li>
</ul>
<script type="text/javascript">
							document.getElementById("alltags_navbar_bottom").style.display = (window == top) ? "block" : "none";
						</script><a name="skip-navbar_bottom"></a>
</div>
<p class="about">Output generated by <a href="http://vdldoc.omnifaces.org" target="_blank">Vdldoc</a> View Declaration Language Documentation Generator.</p>
</body>
</html>
